Mikulić, Petra (0036490588), vrsta: 2. - 5

Pozdrav kolega!

Problem #1
Generalno gledano jako lijepo riješen prvi zadatak. Evo nekoliko sugestija:
- u ChangeCounteru nema potrebe da inicijaliziraš numberOfChanges na 0 jer se članske varijable
postavljaju na defaultne vrijednosti: primitivi na 0, a objekti na null
- u DoubleValue konstruktoru trebao si provjeriti je li number > 0. Ovako ako unesem negativnu vrijednost
observer neće raditi u skladu sa specifikacijom
- sviđa mi se kako si riješio problem sa uklanjanjem observera iz subjekta
- pripazi, na ovoj vještini je pravilo da uvijek koristimo vitice na blokovskim naredbama
- pokušaj uvijek prilikom ispisa koristiti String.format puno je čitljivije :)


Problem #2
- ponovno, u konstruktoru PrimesCollection trebao si provjeriti je li number > 0
- pokušaj uvijek napisati provjeru nekog uvjeta tako da ispituješ neispravan slučaj, puno je čitljivije, tj. umjesto:
if (checkLimit()) {
  // bla bla
} else {
  throw new IllegalStateException("You already generated all numbers!");
}
puno je bolje:
if (!checkLimit()) {
 throw new IllegalStateException("You already generated all numbers!");
}
// bla bla 

- super bi bilo da si izračun prostog broja izdvojio u zasebnu metodu
- prilikom računanja prostog broja nije potrebno provjeravati sve brojeve do n, dovoljno je ići do sqrt(n)


Problem #3
Bilo bi bolje da si umjesto ovog ogromnog switch-casea u metodi calculate u ValueWrapperu koristio strategiju. Osim toga jako lijepo 
riješen zadatak i detaljni testovi. :)


Problem #4
Bilo bi lijepo da si ispisao rezultate metoda, iako nije bilo obavezno, radi lakšeg recenziranja :) Osim toga nemam drugih primjedbi.

Jako lijepo riješena zadaća. Detaljna dokumentacija i testovi. Samo tako nastavi :)



Spajić, Hrvoje (0036494615), vrsta: 1. - 5

ObjectMultistack
 - zasto koristis TreeMap? Mislim da je ovdje nepotreban, a radi nesto sporije
 - neke metode mogu baciti iznimku, a to nisi dokumentirao. Npr., metoda peek
 
ValueWrapper
 - mislim da ovo s usporedjivanjem Stringova nije dobra ideja. Jos vidi da imas ogromno ponavljanje koda i to unutar jedne metode 
 (calculate)
 
Nisi trebao praviti svoj Exception za Multistack. Vec postoji prikladan Exception 
https://docs.oracle.com/javase/7/docs/api/java/util/EmptyStackException.html

PrimesCollection
 - ovo sto radi checkLimit moze radit hasNext()
 - u next trazenje prostog broja je moglo ici do sqrt(i) + 1, a j si mogao povecavati za 2
 
StudentDemo
 - collect(Collectors.toMap(e -> e.getGrade(), t -> Integer.valueOf(1), (i, j) -> (i + j)));
	Mogao si napisati t -> 1 jer interno rade istu stvar, a drugo je citljivije
	Isto tao si mogao napisati ( i, j) -> i + 1 

JavaDoc bi mogao biti bolji na nekim mjestima

Test za ObjectMultistack bi mogao biti bolji

U pom.xml ti pod ima jos uvije stoji "Hello World application"



Sršen, Martin (0036502135), vrsta: 1. - 4

U addObeserver ne provjeravas dali je dati observer null value.

PrimesCollection, u konstruktoru nema provjere dali je dani broj < 1.
U iteratoru je checkLimit metoda potpuno nepotrebna.
Ljepse bi bilo napraviti metodu isPrime koja gleda dali je broj primarni ili ne.

Metoda calculate u valueWrapperu previse velika i nepregledna.
Mogao si jednostavnije napisati da umjesto Stringa saljes binaryOperator function koji ce obaviti posao.
Ovo: Double.valueOf(Double.parseDouble(String.valueOf(number))) ,u tvom kodu bi bilo identicno => return number;

ObjectMultiStack, nema smisla koristiti TreeMap, nema potrebe za sortiranjem, nemotreban utrošak vremena.
pop,peek nema provjere dali je null poslan kao key.

U studentDemo bi bilo lijepo da si svaku tocnu u novi red kod streamova,radi preglednosti, nije greska,samo savjet.

Općenito ,sviđa mi se kod i njegova čitljivost osim metode calculate.Javadoc je uredan.
Zbog korištenja treemap umjesto hashMap,metode calculate moram ti dati ocjenu manje = 4.



Stipić, Dominik (0036501052), vrsta: 1. - 4

2.
During the dispatching of notifications, for a single change only a single instance of IntegerStorageChange c
lass should be created and a reference to that instance should be passed to all registered observers ---> (the order is not important)
 <---. Since this instance provides only a read-only properties, we do not expect any problems.

Trebalo je izabrati takvu kolekciju u kojoj poredak nije bitan.Naravno,trebalo je koristiti Set(HashSet). 
Zasto HashSet? Pa zato jer omogućuje dodavanje i brisanje u složenosti O(1).

3.
Imenovao si varijable koje iteriraju kroz polje "i" i "j". Nemoj ih tako nazivati, koristi neka smislenija imena. 
Metoda checkLimit() ima jednu liniju koda,bespotrebno je raditi novu metodu radi jedne linije koda. Bolje bi bilo da si funkcionalnost od 
checkLimit() preselio u hasNext() i u početku next() pozivao hasNext().Ovako nekako:

public boolean hasNext() {
     return numberOfGenerated < limit;
}
public Integer next(){
     if (!hasNext()){ throw new ....}
	...
}


ValueWrapper
------------
Umjesto Stringova : "add","subtract","multiply","divide" , koristiti enumove.
Metoda calculate() bi bila urednije napisana ako bi kao argument primala funkcijska 
sučelja i na temelju njih obavljala aritmetičke operacije. Time bi se smanjila količina koda i 
kod bi bio čitljiviji 


Sažetak
Zadaća je dobro napisana i sve radi korektno.Imaš nekoliko manjih pogrešaka zbog kojih dajem ocjenu 4.